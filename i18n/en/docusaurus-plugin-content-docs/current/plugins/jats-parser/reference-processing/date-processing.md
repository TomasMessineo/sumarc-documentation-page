---
sidebar_position: 4
---

# 4. CSL Date Format Injection

## 1. Introduction
This functionality allows the bibliographic references generated by the `JatsParser` plugin to respect the short date format configured in the OJS journal. Previously, the date format was fixed in the CSL file, ignoring journal preferences and the article language.

## 2. OJS Configuration (User Guide)
To modify the format in which dates appear in bibliographic references, the journal manager must follow these steps in the administration panel:

1.  Go to **Website** > **Setup** > **Date & Time**.
2.  Find the **Date format (short)** field.
3.  Enter the desired format.
    *   **Common examples:**
        *   `d-m-Y`  → 20-01-2025
        *   `d.m.Y`  → 20.01.2025
        *   `d of F of Y` → 20 of January of 2025
    *   **Available Tokens:**
        *   `d`: Day with leading zero (01-31)
        *   `j`: Day without leading zero (1-31)
        *   `m`: Month with leading zero (01-12)
        *   `n`: Month without leading zero (1-12)
        *   `M`: Short month name (Jan, Feb)
        *   `F`: Full month name (January, February)
        *   `Y`: Year (2025)

**Note on Languages:** The system respects the **article (submission) language**. This is fundamental for consistency in multilingual journals:
*   If an article is configured in **English ("en")**, the system will use:
    1.  The short date format defined for English in OJS.
    2.  English month names.
*   If an article is in **Spanish ("es")**, it will use the Spanish format and names.

This happens regardless of the language in which the administrator is viewing the dashboard. It always takes the submission's `Locale Key`.

---

## 3. Technical Implementation

### Solution Summary
The date processing system is based on a mechanism that intercepts CSL citation generation.

1.  **Orchestration:** `JatsParserPlugin` retrieves the date format based on the submission *locale* and passes it to the `Document`.
2.  **Logic:** The `DateFormatter` class receives this format, parses it (supporting PHP and OJS `strftime` formats), and converts it into CSL-compatible XML structures (`<date-part>`).
3.  **Injection:** The date macro in the `.csl` file is dynamically substituted before processing it with `citeproc-php`.

### Code Structure

#### A. Class `src/JATSParser/HTML/CSL/DateFormatter.php`
This class is responsible for the conversion logic. It handles smart detection of connective words (like "de" or "of") and the correct assignment of separators (dots, dashes) depending on their position relative to the year.

```php
<?php
namespace JATSParser\HTML\CSL;

class DateFormatter {

    /**
     * Injects the OJS date format into the CSL content.
     */
    public function injectOJSDateFormat(string $cslContent, string $dateFormat): string {
        $generatedDateXml = $this->mapPhpDateToCsl($dateFormat);
        
        // Debug log
        error_log("DateFormatter: Generated CSL Date XML: " . $generatedDateXml);

        // Builds the CSL date group
        $newMacroContent = '<group delimiter=" " prefix="(" suffix=")">' .
                           '<choose>' .
                           '<if variable="issued">' .
                           '<date variable="issued">' . $generatedDateXml . '</date>' .
                           '</if>' .
                           '<else>' .
                           '<text term="no date" form="short"/>' .
                           '<text variable="year-suffix" prefix="-"/>' .
                           '</else>' .
                           '</choose>' .
                           '</group>';

        // Replaces the existing 'date-bib' macro
        $pattern = '/<macro name="date-bib">.*?<\/macro>/s';
        $replacement = '<macro name="date-bib">' . $newMacroContent . '</macro>';

        return preg_replace($pattern, $replacement, $cslContent);
    }

    private function mapPhpDateToCsl(string $format): string {
        $xml = '';
        
        // Support for OJS strftime formats (e.g. %Y-%m-%d)
        if (strpos($format, '%') !== false) {
            $strftimeMap = [
                '%Y' => 'Y', '%y' => 'y', 
                '%m' => 'm', '%d' => 'd', '%e' => 'j',
                '%B' => 'F', '%b' => 'M', '%h' => 'M',
            ];
            $format = strtr($format, $strftimeMap);
            $format = str_replace('%', '', $format);
        }

        $tokens = [];
        $length = strlen($format);
        $buffer = '';
        
        $validTokens = ['d', 'j', 'm', 'n', 'F', 'M', 'Y', 'y'];

        // Tokenization with Heuristics for words like "de", "of", etc.
        for ($i = 0; $i < $length; $i++) {
            $char = $format[$i];
            if ($char === '\\') { // Manual escape
                if ($i + 1 < $length) { $buffer .= $format[$i + 1]; $i++; }
                continue;
            }

            if (in_array($char, $validTokens)) {
                // If a token (e.g. 'd') is immediately followed by a letter,
                // we assume it is part of a word (e.g. "de") and NOT a date.
                $isToken = true;
                if ($i + 1 < $length) {
                    $nextChar = $format[$i + 1];
                    if (preg_match('/[a-zA-Z]/', $nextChar) && !in_array($nextChar, $validTokens)) {
                        $isToken = false;
                    }
                }

                if ($isToken) {
                    if ($buffer !== '') {
                        $tokens[] = ['type' => 'delim', 'value' => $buffer];
                        $buffer = '';
                    }
                    $tokens[] = ['type' => 'part', 'value' => $char];
                } else {
                    $buffer .= $char;
                }
            } else {
                $buffer .= $char;
            }
        }
        if ($buffer !== '') {
            $tokens[] = ['type' => 'delim', 'value' => $buffer];
        }

        // "Pivot by Year" Logic: Assign delimiters
        // - Before Year: They are SUFFIXES of the previous element.
        // - After Year: They are PREFIXES of the next element.
        // - The Year does not have attached delimiters.
        $yearIndex = -1;
        for ($i = 0; $i < count($tokens); $i++) {
            if ($tokens[$i]['type'] === 'part' && ($tokens[$i]['value'] === 'Y' || $tokens[$i]['value'] === 'y')) {
                $yearIndex = $i;
                break;
            }
        }

        for ($i = 0; $i < count($tokens); $i++) {
            $token = $tokens[$i];
            if ($token['type'] === 'part') {
                $prefix = '';
                $suffix = '';

                if ($yearIndex > -1) {
                    if ($i < $yearIndex) {
                        // Before year: Next delimiter is Suffix
                        if (isset($tokens[$i + 1]) && $tokens[$i + 1]['type'] === 'delim') {
                            $suffix = $tokens[$i + 1]['value'];
                        }
                        if ($i === 1 && $tokens[0]['type'] === 'delim') $prefix = $tokens[0]['value'];
                    } elseif ($i > $yearIndex) {
                        // After year: Previous delimiter is Prefix
                        if ($i > 0 && $tokens[$i - 1]['type'] === 'delim') {
                            $prefix = $tokens[$i - 1]['value'];
                        }
                        if ($i === count($tokens) - 2 && $tokens[$i + 1]['type'] === 'delim') $suffix = $tokens[$i + 1]['value'];
                    } else {
                        // Year: check extreme edges
                        if ($i === 1 && $tokens[0]['type'] === 'delim') $prefix = $tokens[0]['value'];
                        if ($i === count($tokens) - 2 && $tokens[$i + 1]['type'] === 'delim') $suffix = $tokens[$i + 1]['value'];
                    }
                } else {
                    // Fallback
                    if (isset($tokens[$i + 1]) && $tokens[$i + 1]['type'] === 'delim') $suffix = $tokens[$i + 1]['value'];
                }

                $char = $token['value'];
                // Mapping to CSL XML
                switch ($char) {
                    case 'd': $xml .= $this->createDatePartXml('day', 'numeric-leading-zeros', $prefix, $suffix); break;
                    case 'j': $xml .= $this->createDatePartXml('day', 'numeric', $prefix, $suffix); break;
                    case 'm': $xml .= $this->createDatePartXml('month', 'numeric-leading-zeros', $prefix, $suffix); break;
                    case 'n': $xml .= $this->createDatePartXml('month', 'numeric', $prefix, $suffix); break;
                    case 'F': $xml .= $this->createDatePartXml('month', 'long', $prefix, $suffix); break;
                    case 'M': $xml .= $this->createDatePartXml('month', 'short', $prefix, $suffix); break;
                    case 'Y': $xml .= $this->createDatePartXml('year', 'long', $prefix, $suffix); break;
                    case 'y': $xml .= $this->createDatePartXml('year', 'short', $prefix, $suffix); break;
                }
            }
        }
        return $xml;
    }

    private function createDatePartXml($name, $form, $prefix, $suffix): string {
        $attrs = 'name="' . $name . '"';
        if ($form) $attrs .= ' form="' . $form . '"';
        if ($prefix) $attrs .= ' prefix="' . htmlspecialchars($prefix) . '"';
        if ($suffix) $attrs .= ' suffix="' . htmlspecialchars($suffix) . '"';
        return '<date-part ' . $attrs . '/>';
    }
}
```

#### B. Integration in `JatsParserPlugin.inc.php`
This file retrieves the journal's date format configuration and selects the correct locale.

```php
$lang = str_replace('_', '-', $submissionFile->getSubmissionLocale());
$dateFormat = $context->getSetting('dateFormatShort');

// Fix: Use the SUBMISSION language, not the administrative session one
if (is_array($dateFormat)) {
    $locale = $submissionFile->getSubmissionLocale(); 
    $dateFormat = $dateFormat[$locale] ?? reset($dateFormat);
}

// $dateFormat is passed as 4th parameter
$htmlDocument->setReferences($citationStyle, $lang, false, $dateFormat);
```

#### C. Integration in `src/JATSParser/HTML/Document.php`
The document uses the `DateFormatter` to apply the format before generating the references.

```php
use JATSParser\HTML\CSL\DateFormatter; // Import

// ...

public function setReferences(..., string $dateFormat = null): void {
    // ...
    if (!empty($this->jatsDocument->getReferences())) {
        // Pass dateFormat to extractReferences
        $this->extractReferences($this->jatsDocument->getReferences(), $dateFormat);
    }
}

protected function extractReferences(array $references, string $dateFormat = null): void {
    // ...
    if ($dateFormat) {
        $cslContent = file_get_contents($styleName);
        if ($cslContent) {
            // Instantiate formatter and process
            $dateFormatter = new DateFormatter();
            $cslContent = $dateFormatter->injectOJSDateFormat($cslContent, $dateFormat);
            
            // Save temporary .csl for citeproc to read
            $tempStyleFile = tempnam(sys_get_temp_dir(), 'csl_') . '.csl';
            file_put_contents($tempStyleFile, $cslContent);
            $styleName = $tempStyleFile;
        }
    }
    // ...
}
```
